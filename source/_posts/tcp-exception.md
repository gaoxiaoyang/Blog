---
title: TCP 通信异常情况分析
date: 2021-03-04 15:03:59
tags:
- TCP
---

#### TCP 建立连接时会进行三次握手

#### TCP 断开时会进行四次挥手

<!--more-->

#### TCP 异常情况

1. **试图与一个不存在的端口建立连接 (主机正常)**

   这种情况我们的客户端通常会收到如下异常信息:

   ~~~bash
   Connection refused（连接拒绝）
   ~~~

   wireshark抓包如下, 可以看的RST报文
![](..\imgs\tcp\tcp_connect_no_port.jpg)

2. **试图与一个某端口建立连接但该主机已经宕机 (主机宕机)**

   这也是一种比较常见的情况，当某台服务器主机宕机了，而客户端并不知道，仍然尝试去与其建立连接。这种场景也是分为2种情况的，一种是刚刚宕机，另外一种是宕机了很长时间。**为什么要分这2种情况？**

   这主要根ARP协议有关系，ARP会在本地缓存失效，TCP客户端就无法想目的服务端发送数据包了。

   了解了上述情况，我们分析一下刚刚宕机的情况，此时客户端是可以向服务端发送数据包的。但是由于服务器宕机，因此不会给客户端发送任何回复
![](..\imgs\tcp\tcp_connect_err.jpg)
   
   由于客户端并不知道服务端宕机，因此会重复发送SYN数据包，如图6所示，可以看到客户端每隔几秒会向服务端发送一个SYN数据包。这里面具体的时间是跟TCP协议相关的，具体时间不同的操作系统实现可能稍有不同

3. **建立连接时，服务器应用被阻塞 (或者僵死)**

#### 异常一.  服务进程crash

我们分别写客户端和服务端的程序，客户端不断的发送数据，服务端接收数据。异常的模拟很简单，我们可以在服务端制造一个指针访问异常。此时服务端的程序就会crash掉。然后我们观察客户端的表现。先上结果，客户端的表现如下图所示
![](..\imgs\tcp\tcpclient_send.jpg)

可以看到客户端被reset掉了。我们在结合通过wireshark抓获的此时的数据报文内容，可以看到是一个RST报文

![](..\imgs\tcp\tcpclient_send_rst.png)

回忆一下什么情况下服务端会发送RST报文。这种场景跟我们前面介绍的服务端没有监听的情况是类似的。由于服务端程序crash了，此时在操作系统中的套接字数据结构已经被释放，因此在协议层收到数据包的时候无法找到对应的套接字进行处理，于是发送了一个RST报文

#### 异常二. 手动杀死服务进程

也是线上比较常见的操作，当一个服务上线时，运维总是会先把旧的进程杀死，然后再启动新的进程。**那么在这个过程中TCP连接又会发生了什么呢？是否会像上一种情况一样被RST呢？**同样，我们先看一下结果，如下是客户端的情况
![](..\imgs\tcp\exception2-tcpclient_send.png)

从上面错误码来看是管道破裂，其实也就是连接被中断了。我们再看一下通过wireshark的抓包结果可以看出服务端发送了一个FIN报文，这个报文表示服务端发起了关闭的请求。而接下来的一个报文是客户端对该请求的确认

![](..\imgs\tcp\exception2-wireshark.png)

所以，从上面客户端的错误码和抓包我们可以知道，在kill进程时TCP协议栈是能够感知到的，并且发送的FIN报文

我们再进一步的思考一下，**为什么kill进程会有FIN呢？这个与前面crash的差异在哪？**其实kill进程是通过shell想内核发送了SIGKILL或者SIGTERM，内核接收到该信号之后会进行相应的扫尾工作，因此可以看到服务端发送了FIN报文

#### 异常三.  服务进程所在的主机关机

主机关机（这里指手动关机）的情况与进程被kill是类似的。这时因为在系统关闭时，init进程会给所有进程发送SIGTERM信号，等待一段时间（5~20秒），然后再给所有仍在运行的进程发送SIGKILL信号。当服务器进程死掉时，会关闭所有文件描述符。带来的影响和上面杀死server相同

#### 异常四. 服务进程所在的主机宕机

这是我们线上另一种比较常见的状况。即使宕机是一个小概率事件，线上几千台服务器动不动一两台挂掉也是常有的事。这里挂掉其实包括2种情况，**一种是内核panic，另外一种情况是出现了掉电**。对于内核panic的情况不会像关机那样会预先杀死上面的进程，而是突然性的。那么此时我们的客户端准备给服务器端发送一个请求，它由write写入内核，由TCP作为一个报文发出，但因为主机已经挂掉，因此客户端无法收到ACK。于是客户端TCP持续重传分节，试图从服务器上接收一个ACK，然而服务器始终不能应答，重传数次之后，**大约几分钟才停止**，之后返回一个ETIMEDOUT错误。在这种情况下，如果我们调用的是同步发送接口，则在发送缓冲区慢的情况下会阻塞在这里，导致程序阻塞。

这个时间真的很长，**对于某些应用这种长时间的卡顿是不能接受的**。因此，需要一种手段处理这种情况，在套接字接口中可以通过SO_SNDTIMEO标记进行设置。但是有利也有弊，如果设置了该参数，可能会出现这的数据发送超时的情况，进而出现向服务端发送重复数据的情况，此时需要服务端做去重处理

#### 异常五.  服务进程所在的主机宕机后重启

在客户端发出请求前，服务器端主机经历了**宕机—重启**的过程。当客户端TCP把分节发送到服务器端所在的主机，服务器端所在主机的TCP丢失了崩溃前所有连接信息，即TCP收到了一个根本不存在连接上（也就是我们前文介绍的查找不到socket数据结构）的报文，所以会响应一个RST分节。

至此，关于TCP协议中各种异常情况介绍完了，详细了解这些内容后对后续线上问题的分析和解决会有很大的帮助。当然，也有可能还有其它本文没有介绍到的异常情况